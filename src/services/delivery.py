import aiosmtplib
import markdown
from email.message import EmailMessage
from src.config import settings
from src.services.logger import logger

async def send_email(subject: str, markdown_content: str):
    if not settings.EMAIL_FROM or not settings.EMAIL_TO or not settings.EMAIL_PASSWORD:
        logger.warning("Email configuration missing. Skipping email delivery.")
        return

    message = EmailMessage()
    message["From"] = settings.EMAIL_FROM
    message["To"] = settings.EMAIL_TO
    message["Subject"] = subject

    # Convert Markdown to HTML
    html_body = markdown.markdown(markdown_content)
    
    # Wrap in simple template
    full_html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }}
            h1 {{ color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }}
            h2 {{ color: #2980b9; margin-top: 30px; border-bottom: 1px solid #eee; padding-bottom: 5px; }}
            h3 {{ color: #16a085; margin-top: 20px; }}
            a {{ color: #3498db; text-decoration: none; font-weight: bold; }}
            blockquote {{ border-left: 4px solid #ddd; padding-left: 15px; color: #555; background: #f9f9f9; padding: 10px; }}
            hr {{ border: 0; height: 1px; background: #eee; margin: 30px 0; }}
            .footer {{ font-size: 0.8em; color: #7f8c8d; text-align: center; }}
        </style>
    </head>
    <body>
        <div class="content">
            {html_body}
        </div>
        <hr>
        <div class="footer">
            <p>Generated by AI Intelligence Digest</p>
        </div>
    </body>
    </html>
    """
    
    message.set_content(markdown_content) # Fallback plain text
    message.add_alternative(full_html, subtype='html')

    try:
        logger.info(f"Sending email to {settings.EMAIL_TO}...")
        
        # Use implicit SSL on port 465 (usually more reliable than STARTTLS on 587)
        # If port is 587, we use start_tls. If 465, we use use_tls=True.
        
        use_tls = False
        start_tls = True
        
        if settings.EMAIL_SMTP_PORT == 465:
            use_tls = True
            start_tls = False
            
        await aiosmtplib.send(
            message,
            hostname=settings.EMAIL_SMTP_HOST,
            port=settings.EMAIL_SMTP_PORT,
            username=settings.EMAIL_FROM,
            password=settings.EMAIL_PASSWORD,
            use_tls=use_tls,
            start_tls=start_tls,
            timeout=settings.EMAIL_TIMEOUT # Configurable timeout
        )
        logger.info("Email sent successfully.")
    except Exception as e:
        logger.error(f"Failed to send email: {e}")

import httpx

async def send_telegram(markdown_content: str):
    if not settings.TELEGRAM_BOT_TOKEN or not settings.TELEGRAM_CHAT_ID:
        logger.warning("Telegram configuration missing. Skipping Telegram delivery.")
        return

    logger.info(f"Sending Telegram message to {settings.TELEGRAM_CHAT_ID}...")
    
    # Basic Markdown cleaning/escaping for Telegram might be needed or use ParseMode.MARKDOWN
    # For now, let's just send plain text or minimal markdown if possible.
    # Telegram MarkdownV2 is strict. Let's stick to standard text or HTML if simple.
    # Actually, let's try sending as plain text to avoid parse errors for now, or use 'Markdown' mode cautiously.
    
    # Telegram limit is 4096 chars.
    # We will split by double newline.
    
    chunks = []
    current_chunk = ""
    
    for line in markdown_content.split('\n'):
        if len(current_chunk) + len(line) + 1 > 4000:
            chunks.append(current_chunk)
            current_chunk = ""
        current_chunk += line + "\n"
    if current_chunk:
        chunks.append(current_chunk)

    async with httpx.AsyncClient() as client:
        for i, chunk in enumerate(chunks):
            try:
                url = f"https://api.telegram.org/bot{settings.TELEGRAM_BOT_TOKEN}/sendMessage"
                payload = {
                    "chat_id": settings.TELEGRAM_CHAT_ID,
                    "text": chunk,
                    # "parse_mode": "Markdown" # Disabled to prevent widespread errors with unescaped chars
                }
                resp = await client.post(url, json=payload, timeout=10.0)
                if resp.status_code != 200:
                    logger.error(f"Telegram send failed: {resp.text}")
                else:
                    logger.info(f"Telegram chunk {i+1}/{len(chunks)} sent.")
            except Exception as e:
                logger.error(f"Telegram transport failed: {e}")

